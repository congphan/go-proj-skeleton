// generated by "charlatan -dir=/home/congphan/Golang/src/github.com/congphan/go-prj-skeleton/app/domain/repo -output=/home/congphan/Golang/src/github.com/congphan/go-prj-skeleton/app/domain/repo/mock/mock.go -package=mock UserRepo AccountRepo TransactionRepo".  DO NOT EDIT.

package mock

import "reflect"
import "go-prj-skeleton/app/domain/model"

// UserRepoFindByIDInvocation represents a single call of FakeUserRepo.FindByID
type UserRepoFindByIDInvocation struct {
	Parameters struct {
		Id int
	}
	Results struct {
		Ident1 model.User
		Ident2 error
	}
}

// NewUserRepoFindByIDInvocation creates a new instance of UserRepoFindByIDInvocation
func NewUserRepoFindByIDInvocation(id int, ident1 model.User, ident2 error) *UserRepoFindByIDInvocation {
	invocation := new(UserRepoFindByIDInvocation)

	invocation.Parameters.Id = id

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return invocation
}

// UserRepoTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type UserRepoTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeUserRepo is a mock implementation of UserRepo for testing.
Use it in your tests as in this example:

	package example

	func TestWithUserRepo(t *testing.T) {
		f := &mock.FakeUserRepo{
			FindByIDHook: func(id int) (ident1 model.User, ident2 error) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeFindByID ...
		f.AssertFindByIDCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeFindByID.
*/
type FakeUserRepo struct {
	FindByIDHook func(int) (model.User, error)

	FindByIDCalls []*UserRepoFindByIDInvocation
}

// NewFakeUserRepoDefaultPanic returns an instance of FakeUserRepo with all hooks configured to panic
func NewFakeUserRepoDefaultPanic() *FakeUserRepo {
	return &FakeUserRepo{
		FindByIDHook: func(int) (ident1 model.User, ident2 error) {
			panic("Unexpected call to UserRepo.FindByID")
		},
	}
}

// NewFakeUserRepoDefaultFatal returns an instance of FakeUserRepo with all hooks configured to call t.Fatal
func NewFakeUserRepoDefaultFatal(t_sym1 UserRepoTestingT) *FakeUserRepo {
	return &FakeUserRepo{
		FindByIDHook: func(int) (ident1 model.User, ident2 error) {
			t_sym1.Fatal("Unexpected call to UserRepo.FindByID")
			return
		},
	}
}

// NewFakeUserRepoDefaultError returns an instance of FakeUserRepo with all hooks configured to call t.Error
func NewFakeUserRepoDefaultError(t_sym2 UserRepoTestingT) *FakeUserRepo {
	return &FakeUserRepo{
		FindByIDHook: func(int) (ident1 model.User, ident2 error) {
			t_sym2.Error("Unexpected call to UserRepo.FindByID")
			return
		},
	}
}

func (f *FakeUserRepo) Reset() {
	f.FindByIDCalls = []*UserRepoFindByIDInvocation{}
}

func (f_sym3 *FakeUserRepo) FindByID(id int) (ident1 model.User, ident2 error) {
	if f_sym3.FindByIDHook == nil {
		panic("UserRepo.FindByID() called but FakeUserRepo.FindByIDHook is nil")
	}

	invocation_sym3 := new(UserRepoFindByIDInvocation)
	f_sym3.FindByIDCalls = append(f_sym3.FindByIDCalls, invocation_sym3)

	invocation_sym3.Parameters.Id = id

	ident1, ident2 = f_sym3.FindByIDHook(id)

	invocation_sym3.Results.Ident1 = ident1
	invocation_sym3.Results.Ident2 = ident2

	return
}

// SetFindByIDStub configures UserRepo.FindByID to always return the given values
func (f_sym4 *FakeUserRepo) SetFindByIDStub(ident1 model.User, ident2 error) {
	f_sym4.FindByIDHook = func(int) (model.User, error) {
		return ident1, ident2
	}
}

// SetFindByIDInvocation configures UserRepo.FindByID to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym5 *FakeUserRepo) SetFindByIDInvocation(calls_sym5 []*UserRepoFindByIDInvocation, fallback_sym5 func() (model.User, error)) {
	f_sym5.FindByIDHook = func(id int) (ident1 model.User, ident2 error) {
		for _, call_sym5 := range calls_sym5 {
			if reflect.DeepEqual(call_sym5.Parameters.Id, id) {
				ident1 = call_sym5.Results.Ident1
				ident2 = call_sym5.Results.Ident2

				return
			}
		}

		return fallback_sym5()
	}
}

// FindByIDCalled returns true if FakeUserRepo.FindByID was called
func (f *FakeUserRepo) FindByIDCalled() bool {
	return len(f.FindByIDCalls) != 0
}

// AssertFindByIDCalled calls t.Error if FakeUserRepo.FindByID was not called
func (f *FakeUserRepo) AssertFindByIDCalled(t UserRepoTestingT) {
	t.Helper()
	if len(f.FindByIDCalls) == 0 {
		t.Error("FakeUserRepo.FindByID not called, expected at least one")
	}
}

// FindByIDNotCalled returns true if FakeUserRepo.FindByID was not called
func (f *FakeUserRepo) FindByIDNotCalled() bool {
	return len(f.FindByIDCalls) == 0
}

// AssertFindByIDNotCalled calls t.Error if FakeUserRepo.FindByID was called
func (f *FakeUserRepo) AssertFindByIDNotCalled(t UserRepoTestingT) {
	t.Helper()
	if len(f.FindByIDCalls) != 0 {
		t.Error("FakeUserRepo.FindByID called, expected none")
	}
}

// FindByIDCalledOnce returns true if FakeUserRepo.FindByID was called exactly once
func (f *FakeUserRepo) FindByIDCalledOnce() bool {
	return len(f.FindByIDCalls) == 1
}

// AssertFindByIDCalledOnce calls t.Error if FakeUserRepo.FindByID was not called exactly once
func (f *FakeUserRepo) AssertFindByIDCalledOnce(t UserRepoTestingT) {
	t.Helper()
	if len(f.FindByIDCalls) != 1 {
		t.Errorf("FakeUserRepo.FindByID called %d times, expected 1", len(f.FindByIDCalls))
	}
}

// FindByIDCalledN returns true if FakeUserRepo.FindByID was called at least n times
func (f *FakeUserRepo) FindByIDCalledN(n int) bool {
	return len(f.FindByIDCalls) >= n
}

// AssertFindByIDCalledN calls t.Error if FakeUserRepo.FindByID was called less than n times
func (f *FakeUserRepo) AssertFindByIDCalledN(t UserRepoTestingT, n int) {
	t.Helper()
	if len(f.FindByIDCalls) < n {
		t.Errorf("FakeUserRepo.FindByID called %d times, expected >= %d", len(f.FindByIDCalls), n)
	}
}

// FindByIDCalledWith returns true if FakeUserRepo.FindByID was called with the given values
func (f_sym6 *FakeUserRepo) FindByIDCalledWith(id int) bool {
	for _, call_sym6 := range f_sym6.FindByIDCalls {
		if reflect.DeepEqual(call_sym6.Parameters.Id, id) {
			return true
		}
	}

	return false
}

// AssertFindByIDCalledWith calls t.Error if FakeUserRepo.FindByID was not called with the given values
func (f_sym7 *FakeUserRepo) AssertFindByIDCalledWith(t UserRepoTestingT, id int) {
	t.Helper()
	var found_sym7 bool
	for _, call_sym7 := range f_sym7.FindByIDCalls {
		if reflect.DeepEqual(call_sym7.Parameters.Id, id) {
			found_sym7 = true
			break
		}
	}

	if !found_sym7 {
		t.Error("FakeUserRepo.FindByID not called with expected parameters")
	}
}

// FindByIDCalledOnceWith returns true if FakeUserRepo.FindByID was called exactly once with the given values
func (f_sym8 *FakeUserRepo) FindByIDCalledOnceWith(id int) bool {
	var count_sym8 int
	for _, call_sym8 := range f_sym8.FindByIDCalls {
		if reflect.DeepEqual(call_sym8.Parameters.Id, id) {
			count_sym8++
		}
	}

	return count_sym8 == 1
}

// AssertFindByIDCalledOnceWith calls t.Error if FakeUserRepo.FindByID was not called exactly once with the given values
func (f_sym9 *FakeUserRepo) AssertFindByIDCalledOnceWith(t UserRepoTestingT, id int) {
	t.Helper()
	var count_sym9 int
	for _, call_sym9 := range f_sym9.FindByIDCalls {
		if reflect.DeepEqual(call_sym9.Parameters.Id, id) {
			count_sym9++
		}
	}

	if count_sym9 != 1 {
		t.Errorf("FakeUserRepo.FindByID called %d times with expected parameters, expected one", count_sym9)
	}
}

// FindByIDResultsForCall returns the result values for the first call to FakeUserRepo.FindByID with the given values
func (f_sym10 *FakeUserRepo) FindByIDResultsForCall(id int) (ident1 model.User, ident2 error, found_sym10 bool) {
	for _, call_sym10 := range f_sym10.FindByIDCalls {
		if reflect.DeepEqual(call_sym10.Parameters.Id, id) {
			ident1 = call_sym10.Results.Ident1
			ident2 = call_sym10.Results.Ident2
			found_sym10 = true
			break
		}
	}

	return
}

// AccountRepoFindByUserInvocation represents a single call of FakeAccountRepo.FindByUser
type AccountRepoFindByUserInvocation struct {
	Parameters struct {
		UserID int
	}
	Results struct {
		Ident1 []model.Account
		Ident2 error
	}
}

// NewAccountRepoFindByUserInvocation creates a new instance of AccountRepoFindByUserInvocation
func NewAccountRepoFindByUserInvocation(userID int, ident1 []model.Account, ident2 error) *AccountRepoFindByUserInvocation {
	invocation := new(AccountRepoFindByUserInvocation)

	invocation.Parameters.UserID = userID

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return invocation
}

// AccountRepoFindByIDInvocation represents a single call of FakeAccountRepo.FindByID
type AccountRepoFindByIDInvocation struct {
	Parameters struct {
		Id int
	}
	Results struct {
		Ident1 model.Account
		Ident2 error
	}
}

// NewAccountRepoFindByIDInvocation creates a new instance of AccountRepoFindByIDInvocation
func NewAccountRepoFindByIDInvocation(id int, ident1 model.Account, ident2 error) *AccountRepoFindByIDInvocation {
	invocation := new(AccountRepoFindByIDInvocation)

	invocation.Parameters.Id = id

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return invocation
}

// AccountRepoTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type AccountRepoTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeAccountRepo is a mock implementation of AccountRepo for testing.
Use it in your tests as in this example:

	package example

	func TestWithAccountRepo(t *testing.T) {
		f := &mock.FakeAccountRepo{
			FindByUserHook: func(userID int) (ident1 []model.Account, ident2 error) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeFindByUser ...
		f.AssertFindByUserCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeFindByUser.
*/
type FakeAccountRepo struct {
	FindByUserHook func(int) ([]model.Account, error)
	FindByIDHook   func(int) (model.Account, error)

	FindByUserCalls []*AccountRepoFindByUserInvocation
	FindByIDCalls   []*AccountRepoFindByIDInvocation
}

// NewFakeAccountRepoDefaultPanic returns an instance of FakeAccountRepo with all hooks configured to panic
func NewFakeAccountRepoDefaultPanic() *FakeAccountRepo {
	return &FakeAccountRepo{
		FindByUserHook: func(int) (ident1 []model.Account, ident2 error) {
			panic("Unexpected call to AccountRepo.FindByUser")
		},
		FindByIDHook: func(int) (ident1 model.Account, ident2 error) {
			panic("Unexpected call to AccountRepo.FindByID")
		},
	}
}

// NewFakeAccountRepoDefaultFatal returns an instance of FakeAccountRepo with all hooks configured to call t.Fatal
func NewFakeAccountRepoDefaultFatal(t_sym11 AccountRepoTestingT) *FakeAccountRepo {
	return &FakeAccountRepo{
		FindByUserHook: func(int) (ident1 []model.Account, ident2 error) {
			t_sym11.Fatal("Unexpected call to AccountRepo.FindByUser")
			return
		},
		FindByIDHook: func(int) (ident1 model.Account, ident2 error) {
			t_sym11.Fatal("Unexpected call to AccountRepo.FindByID")
			return
		},
	}
}

// NewFakeAccountRepoDefaultError returns an instance of FakeAccountRepo with all hooks configured to call t.Error
func NewFakeAccountRepoDefaultError(t_sym12 AccountRepoTestingT) *FakeAccountRepo {
	return &FakeAccountRepo{
		FindByUserHook: func(int) (ident1 []model.Account, ident2 error) {
			t_sym12.Error("Unexpected call to AccountRepo.FindByUser")
			return
		},
		FindByIDHook: func(int) (ident1 model.Account, ident2 error) {
			t_sym12.Error("Unexpected call to AccountRepo.FindByID")
			return
		},
	}
}

func (f *FakeAccountRepo) Reset() {
	f.FindByUserCalls = []*AccountRepoFindByUserInvocation{}
	f.FindByIDCalls = []*AccountRepoFindByIDInvocation{}
}

func (f_sym13 *FakeAccountRepo) FindByUser(userID int) (ident1 []model.Account, ident2 error) {
	if f_sym13.FindByUserHook == nil {
		panic("AccountRepo.FindByUser() called but FakeAccountRepo.FindByUserHook is nil")
	}

	invocation_sym13 := new(AccountRepoFindByUserInvocation)
	f_sym13.FindByUserCalls = append(f_sym13.FindByUserCalls, invocation_sym13)

	invocation_sym13.Parameters.UserID = userID

	ident1, ident2 = f_sym13.FindByUserHook(userID)

	invocation_sym13.Results.Ident1 = ident1
	invocation_sym13.Results.Ident2 = ident2

	return
}

// SetFindByUserStub configures AccountRepo.FindByUser to always return the given values
func (f_sym14 *FakeAccountRepo) SetFindByUserStub(ident1 []model.Account, ident2 error) {
	f_sym14.FindByUserHook = func(int) ([]model.Account, error) {
		return ident1, ident2
	}
}

// SetFindByUserInvocation configures AccountRepo.FindByUser to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym15 *FakeAccountRepo) SetFindByUserInvocation(calls_sym15 []*AccountRepoFindByUserInvocation, fallback_sym15 func() ([]model.Account, error)) {
	f_sym15.FindByUserHook = func(userID int) (ident1 []model.Account, ident2 error) {
		for _, call_sym15 := range calls_sym15 {
			if reflect.DeepEqual(call_sym15.Parameters.UserID, userID) {
				ident1 = call_sym15.Results.Ident1
				ident2 = call_sym15.Results.Ident2

				return
			}
		}

		return fallback_sym15()
	}
}

// FindByUserCalled returns true if FakeAccountRepo.FindByUser was called
func (f *FakeAccountRepo) FindByUserCalled() bool {
	return len(f.FindByUserCalls) != 0
}

// AssertFindByUserCalled calls t.Error if FakeAccountRepo.FindByUser was not called
func (f *FakeAccountRepo) AssertFindByUserCalled(t AccountRepoTestingT) {
	t.Helper()
	if len(f.FindByUserCalls) == 0 {
		t.Error("FakeAccountRepo.FindByUser not called, expected at least one")
	}
}

// FindByUserNotCalled returns true if FakeAccountRepo.FindByUser was not called
func (f *FakeAccountRepo) FindByUserNotCalled() bool {
	return len(f.FindByUserCalls) == 0
}

// AssertFindByUserNotCalled calls t.Error if FakeAccountRepo.FindByUser was called
func (f *FakeAccountRepo) AssertFindByUserNotCalled(t AccountRepoTestingT) {
	t.Helper()
	if len(f.FindByUserCalls) != 0 {
		t.Error("FakeAccountRepo.FindByUser called, expected none")
	}
}

// FindByUserCalledOnce returns true if FakeAccountRepo.FindByUser was called exactly once
func (f *FakeAccountRepo) FindByUserCalledOnce() bool {
	return len(f.FindByUserCalls) == 1
}

// AssertFindByUserCalledOnce calls t.Error if FakeAccountRepo.FindByUser was not called exactly once
func (f *FakeAccountRepo) AssertFindByUserCalledOnce(t AccountRepoTestingT) {
	t.Helper()
	if len(f.FindByUserCalls) != 1 {
		t.Errorf("FakeAccountRepo.FindByUser called %d times, expected 1", len(f.FindByUserCalls))
	}
}

// FindByUserCalledN returns true if FakeAccountRepo.FindByUser was called at least n times
func (f *FakeAccountRepo) FindByUserCalledN(n int) bool {
	return len(f.FindByUserCalls) >= n
}

// AssertFindByUserCalledN calls t.Error if FakeAccountRepo.FindByUser was called less than n times
func (f *FakeAccountRepo) AssertFindByUserCalledN(t AccountRepoTestingT, n int) {
	t.Helper()
	if len(f.FindByUserCalls) < n {
		t.Errorf("FakeAccountRepo.FindByUser called %d times, expected >= %d", len(f.FindByUserCalls), n)
	}
}

// FindByUserCalledWith returns true if FakeAccountRepo.FindByUser was called with the given values
func (f_sym16 *FakeAccountRepo) FindByUserCalledWith(userID int) bool {
	for _, call_sym16 := range f_sym16.FindByUserCalls {
		if reflect.DeepEqual(call_sym16.Parameters.UserID, userID) {
			return true
		}
	}

	return false
}

// AssertFindByUserCalledWith calls t.Error if FakeAccountRepo.FindByUser was not called with the given values
func (f_sym17 *FakeAccountRepo) AssertFindByUserCalledWith(t AccountRepoTestingT, userID int) {
	t.Helper()
	var found_sym17 bool
	for _, call_sym17 := range f_sym17.FindByUserCalls {
		if reflect.DeepEqual(call_sym17.Parameters.UserID, userID) {
			found_sym17 = true
			break
		}
	}

	if !found_sym17 {
		t.Error("FakeAccountRepo.FindByUser not called with expected parameters")
	}
}

// FindByUserCalledOnceWith returns true if FakeAccountRepo.FindByUser was called exactly once with the given values
func (f_sym18 *FakeAccountRepo) FindByUserCalledOnceWith(userID int) bool {
	var count_sym18 int
	for _, call_sym18 := range f_sym18.FindByUserCalls {
		if reflect.DeepEqual(call_sym18.Parameters.UserID, userID) {
			count_sym18++
		}
	}

	return count_sym18 == 1
}

// AssertFindByUserCalledOnceWith calls t.Error if FakeAccountRepo.FindByUser was not called exactly once with the given values
func (f_sym19 *FakeAccountRepo) AssertFindByUserCalledOnceWith(t AccountRepoTestingT, userID int) {
	t.Helper()
	var count_sym19 int
	for _, call_sym19 := range f_sym19.FindByUserCalls {
		if reflect.DeepEqual(call_sym19.Parameters.UserID, userID) {
			count_sym19++
		}
	}

	if count_sym19 != 1 {
		t.Errorf("FakeAccountRepo.FindByUser called %d times with expected parameters, expected one", count_sym19)
	}
}

// FindByUserResultsForCall returns the result values for the first call to FakeAccountRepo.FindByUser with the given values
func (f_sym20 *FakeAccountRepo) FindByUserResultsForCall(userID int) (ident1 []model.Account, ident2 error, found_sym20 bool) {
	for _, call_sym20 := range f_sym20.FindByUserCalls {
		if reflect.DeepEqual(call_sym20.Parameters.UserID, userID) {
			ident1 = call_sym20.Results.Ident1
			ident2 = call_sym20.Results.Ident2
			found_sym20 = true
			break
		}
	}

	return
}

func (f_sym21 *FakeAccountRepo) FindByID(id int) (ident1 model.Account, ident2 error) {
	if f_sym21.FindByIDHook == nil {
		panic("AccountRepo.FindByID() called but FakeAccountRepo.FindByIDHook is nil")
	}

	invocation_sym21 := new(AccountRepoFindByIDInvocation)
	f_sym21.FindByIDCalls = append(f_sym21.FindByIDCalls, invocation_sym21)

	invocation_sym21.Parameters.Id = id

	ident1, ident2 = f_sym21.FindByIDHook(id)

	invocation_sym21.Results.Ident1 = ident1
	invocation_sym21.Results.Ident2 = ident2

	return
}

// SetFindByIDStub configures AccountRepo.FindByID to always return the given values
func (f_sym22 *FakeAccountRepo) SetFindByIDStub(ident1 model.Account, ident2 error) {
	f_sym22.FindByIDHook = func(int) (model.Account, error) {
		return ident1, ident2
	}
}

// SetFindByIDInvocation configures AccountRepo.FindByID to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym23 *FakeAccountRepo) SetFindByIDInvocation(calls_sym23 []*AccountRepoFindByIDInvocation, fallback_sym23 func() (model.Account, error)) {
	f_sym23.FindByIDHook = func(id int) (ident1 model.Account, ident2 error) {
		for _, call_sym23 := range calls_sym23 {
			if reflect.DeepEqual(call_sym23.Parameters.Id, id) {
				ident1 = call_sym23.Results.Ident1
				ident2 = call_sym23.Results.Ident2

				return
			}
		}

		return fallback_sym23()
	}
}

// FindByIDCalled returns true if FakeAccountRepo.FindByID was called
func (f *FakeAccountRepo) FindByIDCalled() bool {
	return len(f.FindByIDCalls) != 0
}

// AssertFindByIDCalled calls t.Error if FakeAccountRepo.FindByID was not called
func (f *FakeAccountRepo) AssertFindByIDCalled(t AccountRepoTestingT) {
	t.Helper()
	if len(f.FindByIDCalls) == 0 {
		t.Error("FakeAccountRepo.FindByID not called, expected at least one")
	}
}

// FindByIDNotCalled returns true if FakeAccountRepo.FindByID was not called
func (f *FakeAccountRepo) FindByIDNotCalled() bool {
	return len(f.FindByIDCalls) == 0
}

// AssertFindByIDNotCalled calls t.Error if FakeAccountRepo.FindByID was called
func (f *FakeAccountRepo) AssertFindByIDNotCalled(t AccountRepoTestingT) {
	t.Helper()
	if len(f.FindByIDCalls) != 0 {
		t.Error("FakeAccountRepo.FindByID called, expected none")
	}
}

// FindByIDCalledOnce returns true if FakeAccountRepo.FindByID was called exactly once
func (f *FakeAccountRepo) FindByIDCalledOnce() bool {
	return len(f.FindByIDCalls) == 1
}

// AssertFindByIDCalledOnce calls t.Error if FakeAccountRepo.FindByID was not called exactly once
func (f *FakeAccountRepo) AssertFindByIDCalledOnce(t AccountRepoTestingT) {
	t.Helper()
	if len(f.FindByIDCalls) != 1 {
		t.Errorf("FakeAccountRepo.FindByID called %d times, expected 1", len(f.FindByIDCalls))
	}
}

// FindByIDCalledN returns true if FakeAccountRepo.FindByID was called at least n times
func (f *FakeAccountRepo) FindByIDCalledN(n int) bool {
	return len(f.FindByIDCalls) >= n
}

// AssertFindByIDCalledN calls t.Error if FakeAccountRepo.FindByID was called less than n times
func (f *FakeAccountRepo) AssertFindByIDCalledN(t AccountRepoTestingT, n int) {
	t.Helper()
	if len(f.FindByIDCalls) < n {
		t.Errorf("FakeAccountRepo.FindByID called %d times, expected >= %d", len(f.FindByIDCalls), n)
	}
}

// FindByIDCalledWith returns true if FakeAccountRepo.FindByID was called with the given values
func (f_sym24 *FakeAccountRepo) FindByIDCalledWith(id int) bool {
	for _, call_sym24 := range f_sym24.FindByIDCalls {
		if reflect.DeepEqual(call_sym24.Parameters.Id, id) {
			return true
		}
	}

	return false
}

// AssertFindByIDCalledWith calls t.Error if FakeAccountRepo.FindByID was not called with the given values
func (f_sym25 *FakeAccountRepo) AssertFindByIDCalledWith(t AccountRepoTestingT, id int) {
	t.Helper()
	var found_sym25 bool
	for _, call_sym25 := range f_sym25.FindByIDCalls {
		if reflect.DeepEqual(call_sym25.Parameters.Id, id) {
			found_sym25 = true
			break
		}
	}

	if !found_sym25 {
		t.Error("FakeAccountRepo.FindByID not called with expected parameters")
	}
}

// FindByIDCalledOnceWith returns true if FakeAccountRepo.FindByID was called exactly once with the given values
func (f_sym26 *FakeAccountRepo) FindByIDCalledOnceWith(id int) bool {
	var count_sym26 int
	for _, call_sym26 := range f_sym26.FindByIDCalls {
		if reflect.DeepEqual(call_sym26.Parameters.Id, id) {
			count_sym26++
		}
	}

	return count_sym26 == 1
}

// AssertFindByIDCalledOnceWith calls t.Error if FakeAccountRepo.FindByID was not called exactly once with the given values
func (f_sym27 *FakeAccountRepo) AssertFindByIDCalledOnceWith(t AccountRepoTestingT, id int) {
	t.Helper()
	var count_sym27 int
	for _, call_sym27 := range f_sym27.FindByIDCalls {
		if reflect.DeepEqual(call_sym27.Parameters.Id, id) {
			count_sym27++
		}
	}

	if count_sym27 != 1 {
		t.Errorf("FakeAccountRepo.FindByID called %d times with expected parameters, expected one", count_sym27)
	}
}

// FindByIDResultsForCall returns the result values for the first call to FakeAccountRepo.FindByID with the given values
func (f_sym28 *FakeAccountRepo) FindByIDResultsForCall(id int) (ident1 model.Account, ident2 error, found_sym28 bool) {
	for _, call_sym28 := range f_sym28.FindByIDCalls {
		if reflect.DeepEqual(call_sym28.Parameters.Id, id) {
			ident1 = call_sym28.Results.Ident1
			ident2 = call_sym28.Results.Ident2
			found_sym28 = true
			break
		}
	}

	return
}

// TransactionRepoFindByIDInvocation represents a single call of FakeTransactionRepo.FindByID
type TransactionRepoFindByIDInvocation struct {
	Parameters struct {
		Id int
	}
	Results struct {
		Ident1 model.Transaction
		Ident2 error
	}
}

// NewTransactionRepoFindByIDInvocation creates a new instance of TransactionRepoFindByIDInvocation
func NewTransactionRepoFindByIDInvocation(id int, ident1 model.Transaction, ident2 error) *TransactionRepoFindByIDInvocation {
	invocation := new(TransactionRepoFindByIDInvocation)

	invocation.Parameters.Id = id

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return invocation
}

// TransactionRepoFindByUserInvocation represents a single call of FakeTransactionRepo.FindByUser
type TransactionRepoFindByUserInvocation struct {
	Parameters struct {
		UserID int
	}
	Results struct {
		Ident1 []model.Transaction
		Ident2 error
	}
}

// NewTransactionRepoFindByUserInvocation creates a new instance of TransactionRepoFindByUserInvocation
func NewTransactionRepoFindByUserInvocation(userID int, ident1 []model.Transaction, ident2 error) *TransactionRepoFindByUserInvocation {
	invocation := new(TransactionRepoFindByUserInvocation)

	invocation.Parameters.UserID = userID

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return invocation
}

// TransactionRepoFindByUserAccountInvocation represents a single call of FakeTransactionRepo.FindByUserAccount
type TransactionRepoFindByUserAccountInvocation struct {
	Parameters struct {
		UserID    int
		AccountID int
	}
	Results struct {
		Ident1 []model.Transaction
		Ident2 error
	}
}

// NewTransactionRepoFindByUserAccountInvocation creates a new instance of TransactionRepoFindByUserAccountInvocation
func NewTransactionRepoFindByUserAccountInvocation(userID int, accountID int, ident1 []model.Transaction, ident2 error) *TransactionRepoFindByUserAccountInvocation {
	invocation := new(TransactionRepoFindByUserAccountInvocation)

	invocation.Parameters.UserID = userID
	invocation.Parameters.AccountID = accountID

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return invocation
}

// TransactionRepoCreateInvocation represents a single call of FakeTransactionRepo.Create
type TransactionRepoCreateInvocation struct {
	Parameters struct {
		Ident1 *model.Transaction
	}
	Results struct {
		Ident2 error
	}
}

// NewTransactionRepoCreateInvocation creates a new instance of TransactionRepoCreateInvocation
func NewTransactionRepoCreateInvocation(ident1 *model.Transaction, ident2 error) *TransactionRepoCreateInvocation {
	invocation := new(TransactionRepoCreateInvocation)

	invocation.Parameters.Ident1 = ident1

	invocation.Results.Ident2 = ident2

	return invocation
}

// TransactionRepoUpdateInvocation represents a single call of FakeTransactionRepo.Update
type TransactionRepoUpdateInvocation struct {
	Parameters struct {
		Ident1 *model.Transaction
	}
	Results struct {
		Ident2 error
	}
}

// NewTransactionRepoUpdateInvocation creates a new instance of TransactionRepoUpdateInvocation
func NewTransactionRepoUpdateInvocation(ident1 *model.Transaction, ident2 error) *TransactionRepoUpdateInvocation {
	invocation := new(TransactionRepoUpdateInvocation)

	invocation.Parameters.Ident1 = ident1

	invocation.Results.Ident2 = ident2

	return invocation
}

// TransactionRepoDeleteInvocation represents a single call of FakeTransactionRepo.Delete
type TransactionRepoDeleteInvocation struct {
	Parameters struct {
		UserID int
		TranID int
	}
	Results struct {
		Ident1 error
	}
}

// NewTransactionRepoDeleteInvocation creates a new instance of TransactionRepoDeleteInvocation
func NewTransactionRepoDeleteInvocation(userID int, tranID int, ident1 error) *TransactionRepoDeleteInvocation {
	invocation := new(TransactionRepoDeleteInvocation)

	invocation.Parameters.UserID = userID
	invocation.Parameters.TranID = tranID

	invocation.Results.Ident1 = ident1

	return invocation
}

// TransactionRepoTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type TransactionRepoTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeTransactionRepo is a mock implementation of TransactionRepo for testing.
Use it in your tests as in this example:

	package example

	func TestWithTransactionRepo(t *testing.T) {
		f := &mock.FakeTransactionRepo{
			FindByIDHook: func(id int) (ident1 model.Transaction, ident2 error) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeFindByID ...
		f.AssertFindByIDCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeFindByID.
*/
type FakeTransactionRepo struct {
	FindByIDHook          func(int) (model.Transaction, error)
	FindByUserHook        func(int) ([]model.Transaction, error)
	FindByUserAccountHook func(int, int) ([]model.Transaction, error)
	CreateHook            func(*model.Transaction) error
	UpdateHook            func(*model.Transaction) error
	DeleteHook            func(int, int) error

	FindByIDCalls          []*TransactionRepoFindByIDInvocation
	FindByUserCalls        []*TransactionRepoFindByUserInvocation
	FindByUserAccountCalls []*TransactionRepoFindByUserAccountInvocation
	CreateCalls            []*TransactionRepoCreateInvocation
	UpdateCalls            []*TransactionRepoUpdateInvocation
	DeleteCalls            []*TransactionRepoDeleteInvocation
}

// NewFakeTransactionRepoDefaultPanic returns an instance of FakeTransactionRepo with all hooks configured to panic
func NewFakeTransactionRepoDefaultPanic() *FakeTransactionRepo {
	return &FakeTransactionRepo{
		FindByIDHook: func(int) (ident1 model.Transaction, ident2 error) {
			panic("Unexpected call to TransactionRepo.FindByID")
		},
		FindByUserHook: func(int) (ident1 []model.Transaction, ident2 error) {
			panic("Unexpected call to TransactionRepo.FindByUser")
		},
		FindByUserAccountHook: func(int, int) (ident1 []model.Transaction, ident2 error) {
			panic("Unexpected call to TransactionRepo.FindByUserAccount")
		},
		CreateHook: func(*model.Transaction) (ident2 error) {
			panic("Unexpected call to TransactionRepo.Create")
		},
		UpdateHook: func(*model.Transaction) (ident2 error) {
			panic("Unexpected call to TransactionRepo.Update")
		},
		DeleteHook: func(int, int) (ident1 error) {
			panic("Unexpected call to TransactionRepo.Delete")
		},
	}
}

// NewFakeTransactionRepoDefaultFatal returns an instance of FakeTransactionRepo with all hooks configured to call t.Fatal
func NewFakeTransactionRepoDefaultFatal(t_sym29 TransactionRepoTestingT) *FakeTransactionRepo {
	return &FakeTransactionRepo{
		FindByIDHook: func(int) (ident1 model.Transaction, ident2 error) {
			t_sym29.Fatal("Unexpected call to TransactionRepo.FindByID")
			return
		},
		FindByUserHook: func(int) (ident1 []model.Transaction, ident2 error) {
			t_sym29.Fatal("Unexpected call to TransactionRepo.FindByUser")
			return
		},
		FindByUserAccountHook: func(int, int) (ident1 []model.Transaction, ident2 error) {
			t_sym29.Fatal("Unexpected call to TransactionRepo.FindByUserAccount")
			return
		},
		CreateHook: func(*model.Transaction) (ident2 error) {
			t_sym29.Fatal("Unexpected call to TransactionRepo.Create")
			return
		},
		UpdateHook: func(*model.Transaction) (ident2 error) {
			t_sym29.Fatal("Unexpected call to TransactionRepo.Update")
			return
		},
		DeleteHook: func(int, int) (ident1 error) {
			t_sym29.Fatal("Unexpected call to TransactionRepo.Delete")
			return
		},
	}
}

// NewFakeTransactionRepoDefaultError returns an instance of FakeTransactionRepo with all hooks configured to call t.Error
func NewFakeTransactionRepoDefaultError(t_sym30 TransactionRepoTestingT) *FakeTransactionRepo {
	return &FakeTransactionRepo{
		FindByIDHook: func(int) (ident1 model.Transaction, ident2 error) {
			t_sym30.Error("Unexpected call to TransactionRepo.FindByID")
			return
		},
		FindByUserHook: func(int) (ident1 []model.Transaction, ident2 error) {
			t_sym30.Error("Unexpected call to TransactionRepo.FindByUser")
			return
		},
		FindByUserAccountHook: func(int, int) (ident1 []model.Transaction, ident2 error) {
			t_sym30.Error("Unexpected call to TransactionRepo.FindByUserAccount")
			return
		},
		CreateHook: func(*model.Transaction) (ident2 error) {
			t_sym30.Error("Unexpected call to TransactionRepo.Create")
			return
		},
		UpdateHook: func(*model.Transaction) (ident2 error) {
			t_sym30.Error("Unexpected call to TransactionRepo.Update")
			return
		},
		DeleteHook: func(int, int) (ident1 error) {
			t_sym30.Error("Unexpected call to TransactionRepo.Delete")
			return
		},
	}
}

func (f *FakeTransactionRepo) Reset() {
	f.FindByIDCalls = []*TransactionRepoFindByIDInvocation{}
	f.FindByUserCalls = []*TransactionRepoFindByUserInvocation{}
	f.FindByUserAccountCalls = []*TransactionRepoFindByUserAccountInvocation{}
	f.CreateCalls = []*TransactionRepoCreateInvocation{}
	f.UpdateCalls = []*TransactionRepoUpdateInvocation{}
	f.DeleteCalls = []*TransactionRepoDeleteInvocation{}
}

func (f_sym31 *FakeTransactionRepo) FindByID(id int) (ident1 model.Transaction, ident2 error) {
	if f_sym31.FindByIDHook == nil {
		panic("TransactionRepo.FindByID() called but FakeTransactionRepo.FindByIDHook is nil")
	}

	invocation_sym31 := new(TransactionRepoFindByIDInvocation)
	f_sym31.FindByIDCalls = append(f_sym31.FindByIDCalls, invocation_sym31)

	invocation_sym31.Parameters.Id = id

	ident1, ident2 = f_sym31.FindByIDHook(id)

	invocation_sym31.Results.Ident1 = ident1
	invocation_sym31.Results.Ident2 = ident2

	return
}

// SetFindByIDStub configures TransactionRepo.FindByID to always return the given values
func (f_sym32 *FakeTransactionRepo) SetFindByIDStub(ident1 model.Transaction, ident2 error) {
	f_sym32.FindByIDHook = func(int) (model.Transaction, error) {
		return ident1, ident2
	}
}

// SetFindByIDInvocation configures TransactionRepo.FindByID to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym33 *FakeTransactionRepo) SetFindByIDInvocation(calls_sym33 []*TransactionRepoFindByIDInvocation, fallback_sym33 func() (model.Transaction, error)) {
	f_sym33.FindByIDHook = func(id int) (ident1 model.Transaction, ident2 error) {
		for _, call_sym33 := range calls_sym33 {
			if reflect.DeepEqual(call_sym33.Parameters.Id, id) {
				ident1 = call_sym33.Results.Ident1
				ident2 = call_sym33.Results.Ident2

				return
			}
		}

		return fallback_sym33()
	}
}

// FindByIDCalled returns true if FakeTransactionRepo.FindByID was called
func (f *FakeTransactionRepo) FindByIDCalled() bool {
	return len(f.FindByIDCalls) != 0
}

// AssertFindByIDCalled calls t.Error if FakeTransactionRepo.FindByID was not called
func (f *FakeTransactionRepo) AssertFindByIDCalled(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.FindByIDCalls) == 0 {
		t.Error("FakeTransactionRepo.FindByID not called, expected at least one")
	}
}

// FindByIDNotCalled returns true if FakeTransactionRepo.FindByID was not called
func (f *FakeTransactionRepo) FindByIDNotCalled() bool {
	return len(f.FindByIDCalls) == 0
}

// AssertFindByIDNotCalled calls t.Error if FakeTransactionRepo.FindByID was called
func (f *FakeTransactionRepo) AssertFindByIDNotCalled(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.FindByIDCalls) != 0 {
		t.Error("FakeTransactionRepo.FindByID called, expected none")
	}
}

// FindByIDCalledOnce returns true if FakeTransactionRepo.FindByID was called exactly once
func (f *FakeTransactionRepo) FindByIDCalledOnce() bool {
	return len(f.FindByIDCalls) == 1
}

// AssertFindByIDCalledOnce calls t.Error if FakeTransactionRepo.FindByID was not called exactly once
func (f *FakeTransactionRepo) AssertFindByIDCalledOnce(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.FindByIDCalls) != 1 {
		t.Errorf("FakeTransactionRepo.FindByID called %d times, expected 1", len(f.FindByIDCalls))
	}
}

// FindByIDCalledN returns true if FakeTransactionRepo.FindByID was called at least n times
func (f *FakeTransactionRepo) FindByIDCalledN(n int) bool {
	return len(f.FindByIDCalls) >= n
}

// AssertFindByIDCalledN calls t.Error if FakeTransactionRepo.FindByID was called less than n times
func (f *FakeTransactionRepo) AssertFindByIDCalledN(t TransactionRepoTestingT, n int) {
	t.Helper()
	if len(f.FindByIDCalls) < n {
		t.Errorf("FakeTransactionRepo.FindByID called %d times, expected >= %d", len(f.FindByIDCalls), n)
	}
}

// FindByIDCalledWith returns true if FakeTransactionRepo.FindByID was called with the given values
func (f_sym34 *FakeTransactionRepo) FindByIDCalledWith(id int) bool {
	for _, call_sym34 := range f_sym34.FindByIDCalls {
		if reflect.DeepEqual(call_sym34.Parameters.Id, id) {
			return true
		}
	}

	return false
}

// AssertFindByIDCalledWith calls t.Error if FakeTransactionRepo.FindByID was not called with the given values
func (f_sym35 *FakeTransactionRepo) AssertFindByIDCalledWith(t TransactionRepoTestingT, id int) {
	t.Helper()
	var found_sym35 bool
	for _, call_sym35 := range f_sym35.FindByIDCalls {
		if reflect.DeepEqual(call_sym35.Parameters.Id, id) {
			found_sym35 = true
			break
		}
	}

	if !found_sym35 {
		t.Error("FakeTransactionRepo.FindByID not called with expected parameters")
	}
}

// FindByIDCalledOnceWith returns true if FakeTransactionRepo.FindByID was called exactly once with the given values
func (f_sym36 *FakeTransactionRepo) FindByIDCalledOnceWith(id int) bool {
	var count_sym36 int
	for _, call_sym36 := range f_sym36.FindByIDCalls {
		if reflect.DeepEqual(call_sym36.Parameters.Id, id) {
			count_sym36++
		}
	}

	return count_sym36 == 1
}

// AssertFindByIDCalledOnceWith calls t.Error if FakeTransactionRepo.FindByID was not called exactly once with the given values
func (f_sym37 *FakeTransactionRepo) AssertFindByIDCalledOnceWith(t TransactionRepoTestingT, id int) {
	t.Helper()
	var count_sym37 int
	for _, call_sym37 := range f_sym37.FindByIDCalls {
		if reflect.DeepEqual(call_sym37.Parameters.Id, id) {
			count_sym37++
		}
	}

	if count_sym37 != 1 {
		t.Errorf("FakeTransactionRepo.FindByID called %d times with expected parameters, expected one", count_sym37)
	}
}

// FindByIDResultsForCall returns the result values for the first call to FakeTransactionRepo.FindByID with the given values
func (f_sym38 *FakeTransactionRepo) FindByIDResultsForCall(id int) (ident1 model.Transaction, ident2 error, found_sym38 bool) {
	for _, call_sym38 := range f_sym38.FindByIDCalls {
		if reflect.DeepEqual(call_sym38.Parameters.Id, id) {
			ident1 = call_sym38.Results.Ident1
			ident2 = call_sym38.Results.Ident2
			found_sym38 = true
			break
		}
	}

	return
}

func (f_sym39 *FakeTransactionRepo) FindByUser(userID int) (ident1 []model.Transaction, ident2 error) {
	if f_sym39.FindByUserHook == nil {
		panic("TransactionRepo.FindByUser() called but FakeTransactionRepo.FindByUserHook is nil")
	}

	invocation_sym39 := new(TransactionRepoFindByUserInvocation)
	f_sym39.FindByUserCalls = append(f_sym39.FindByUserCalls, invocation_sym39)

	invocation_sym39.Parameters.UserID = userID

	ident1, ident2 = f_sym39.FindByUserHook(userID)

	invocation_sym39.Results.Ident1 = ident1
	invocation_sym39.Results.Ident2 = ident2

	return
}

// SetFindByUserStub configures TransactionRepo.FindByUser to always return the given values
func (f_sym40 *FakeTransactionRepo) SetFindByUserStub(ident1 []model.Transaction, ident2 error) {
	f_sym40.FindByUserHook = func(int) ([]model.Transaction, error) {
		return ident1, ident2
	}
}

// SetFindByUserInvocation configures TransactionRepo.FindByUser to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym41 *FakeTransactionRepo) SetFindByUserInvocation(calls_sym41 []*TransactionRepoFindByUserInvocation, fallback_sym41 func() ([]model.Transaction, error)) {
	f_sym41.FindByUserHook = func(userID int) (ident1 []model.Transaction, ident2 error) {
		for _, call_sym41 := range calls_sym41 {
			if reflect.DeepEqual(call_sym41.Parameters.UserID, userID) {
				ident1 = call_sym41.Results.Ident1
				ident2 = call_sym41.Results.Ident2

				return
			}
		}

		return fallback_sym41()
	}
}

// FindByUserCalled returns true if FakeTransactionRepo.FindByUser was called
func (f *FakeTransactionRepo) FindByUserCalled() bool {
	return len(f.FindByUserCalls) != 0
}

// AssertFindByUserCalled calls t.Error if FakeTransactionRepo.FindByUser was not called
func (f *FakeTransactionRepo) AssertFindByUserCalled(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.FindByUserCalls) == 0 {
		t.Error("FakeTransactionRepo.FindByUser not called, expected at least one")
	}
}

// FindByUserNotCalled returns true if FakeTransactionRepo.FindByUser was not called
func (f *FakeTransactionRepo) FindByUserNotCalled() bool {
	return len(f.FindByUserCalls) == 0
}

// AssertFindByUserNotCalled calls t.Error if FakeTransactionRepo.FindByUser was called
func (f *FakeTransactionRepo) AssertFindByUserNotCalled(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.FindByUserCalls) != 0 {
		t.Error("FakeTransactionRepo.FindByUser called, expected none")
	}
}

// FindByUserCalledOnce returns true if FakeTransactionRepo.FindByUser was called exactly once
func (f *FakeTransactionRepo) FindByUserCalledOnce() bool {
	return len(f.FindByUserCalls) == 1
}

// AssertFindByUserCalledOnce calls t.Error if FakeTransactionRepo.FindByUser was not called exactly once
func (f *FakeTransactionRepo) AssertFindByUserCalledOnce(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.FindByUserCalls) != 1 {
		t.Errorf("FakeTransactionRepo.FindByUser called %d times, expected 1", len(f.FindByUserCalls))
	}
}

// FindByUserCalledN returns true if FakeTransactionRepo.FindByUser was called at least n times
func (f *FakeTransactionRepo) FindByUserCalledN(n int) bool {
	return len(f.FindByUserCalls) >= n
}

// AssertFindByUserCalledN calls t.Error if FakeTransactionRepo.FindByUser was called less than n times
func (f *FakeTransactionRepo) AssertFindByUserCalledN(t TransactionRepoTestingT, n int) {
	t.Helper()
	if len(f.FindByUserCalls) < n {
		t.Errorf("FakeTransactionRepo.FindByUser called %d times, expected >= %d", len(f.FindByUserCalls), n)
	}
}

// FindByUserCalledWith returns true if FakeTransactionRepo.FindByUser was called with the given values
func (f_sym42 *FakeTransactionRepo) FindByUserCalledWith(userID int) bool {
	for _, call_sym42 := range f_sym42.FindByUserCalls {
		if reflect.DeepEqual(call_sym42.Parameters.UserID, userID) {
			return true
		}
	}

	return false
}

// AssertFindByUserCalledWith calls t.Error if FakeTransactionRepo.FindByUser was not called with the given values
func (f_sym43 *FakeTransactionRepo) AssertFindByUserCalledWith(t TransactionRepoTestingT, userID int) {
	t.Helper()
	var found_sym43 bool
	for _, call_sym43 := range f_sym43.FindByUserCalls {
		if reflect.DeepEqual(call_sym43.Parameters.UserID, userID) {
			found_sym43 = true
			break
		}
	}

	if !found_sym43 {
		t.Error("FakeTransactionRepo.FindByUser not called with expected parameters")
	}
}

// FindByUserCalledOnceWith returns true if FakeTransactionRepo.FindByUser was called exactly once with the given values
func (f_sym44 *FakeTransactionRepo) FindByUserCalledOnceWith(userID int) bool {
	var count_sym44 int
	for _, call_sym44 := range f_sym44.FindByUserCalls {
		if reflect.DeepEqual(call_sym44.Parameters.UserID, userID) {
			count_sym44++
		}
	}

	return count_sym44 == 1
}

// AssertFindByUserCalledOnceWith calls t.Error if FakeTransactionRepo.FindByUser was not called exactly once with the given values
func (f_sym45 *FakeTransactionRepo) AssertFindByUserCalledOnceWith(t TransactionRepoTestingT, userID int) {
	t.Helper()
	var count_sym45 int
	for _, call_sym45 := range f_sym45.FindByUserCalls {
		if reflect.DeepEqual(call_sym45.Parameters.UserID, userID) {
			count_sym45++
		}
	}

	if count_sym45 != 1 {
		t.Errorf("FakeTransactionRepo.FindByUser called %d times with expected parameters, expected one", count_sym45)
	}
}

// FindByUserResultsForCall returns the result values for the first call to FakeTransactionRepo.FindByUser with the given values
func (f_sym46 *FakeTransactionRepo) FindByUserResultsForCall(userID int) (ident1 []model.Transaction, ident2 error, found_sym46 bool) {
	for _, call_sym46 := range f_sym46.FindByUserCalls {
		if reflect.DeepEqual(call_sym46.Parameters.UserID, userID) {
			ident1 = call_sym46.Results.Ident1
			ident2 = call_sym46.Results.Ident2
			found_sym46 = true
			break
		}
	}

	return
}

func (f_sym47 *FakeTransactionRepo) FindByUserAccount(userID int, accountID int) (ident1 []model.Transaction, ident2 error) {
	if f_sym47.FindByUserAccountHook == nil {
		panic("TransactionRepo.FindByUserAccount() called but FakeTransactionRepo.FindByUserAccountHook is nil")
	}

	invocation_sym47 := new(TransactionRepoFindByUserAccountInvocation)
	f_sym47.FindByUserAccountCalls = append(f_sym47.FindByUserAccountCalls, invocation_sym47)

	invocation_sym47.Parameters.UserID = userID
	invocation_sym47.Parameters.AccountID = accountID

	ident1, ident2 = f_sym47.FindByUserAccountHook(userID, accountID)

	invocation_sym47.Results.Ident1 = ident1
	invocation_sym47.Results.Ident2 = ident2

	return
}

// SetFindByUserAccountStub configures TransactionRepo.FindByUserAccount to always return the given values
func (f_sym48 *FakeTransactionRepo) SetFindByUserAccountStub(ident1 []model.Transaction, ident2 error) {
	f_sym48.FindByUserAccountHook = func(int, int) ([]model.Transaction, error) {
		return ident1, ident2
	}
}

// SetFindByUserAccountInvocation configures TransactionRepo.FindByUserAccount to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym49 *FakeTransactionRepo) SetFindByUserAccountInvocation(calls_sym49 []*TransactionRepoFindByUserAccountInvocation, fallback_sym49 func() ([]model.Transaction, error)) {
	f_sym49.FindByUserAccountHook = func(userID int, accountID int) (ident1 []model.Transaction, ident2 error) {
		for _, call_sym49 := range calls_sym49 {
			if reflect.DeepEqual(call_sym49.Parameters.UserID, userID) && reflect.DeepEqual(call_sym49.Parameters.AccountID, accountID) {
				ident1 = call_sym49.Results.Ident1
				ident2 = call_sym49.Results.Ident2

				return
			}
		}

		return fallback_sym49()
	}
}

// FindByUserAccountCalled returns true if FakeTransactionRepo.FindByUserAccount was called
func (f *FakeTransactionRepo) FindByUserAccountCalled() bool {
	return len(f.FindByUserAccountCalls) != 0
}

// AssertFindByUserAccountCalled calls t.Error if FakeTransactionRepo.FindByUserAccount was not called
func (f *FakeTransactionRepo) AssertFindByUserAccountCalled(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.FindByUserAccountCalls) == 0 {
		t.Error("FakeTransactionRepo.FindByUserAccount not called, expected at least one")
	}
}

// FindByUserAccountNotCalled returns true if FakeTransactionRepo.FindByUserAccount was not called
func (f *FakeTransactionRepo) FindByUserAccountNotCalled() bool {
	return len(f.FindByUserAccountCalls) == 0
}

// AssertFindByUserAccountNotCalled calls t.Error if FakeTransactionRepo.FindByUserAccount was called
func (f *FakeTransactionRepo) AssertFindByUserAccountNotCalled(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.FindByUserAccountCalls) != 0 {
		t.Error("FakeTransactionRepo.FindByUserAccount called, expected none")
	}
}

// FindByUserAccountCalledOnce returns true if FakeTransactionRepo.FindByUserAccount was called exactly once
func (f *FakeTransactionRepo) FindByUserAccountCalledOnce() bool {
	return len(f.FindByUserAccountCalls) == 1
}

// AssertFindByUserAccountCalledOnce calls t.Error if FakeTransactionRepo.FindByUserAccount was not called exactly once
func (f *FakeTransactionRepo) AssertFindByUserAccountCalledOnce(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.FindByUserAccountCalls) != 1 {
		t.Errorf("FakeTransactionRepo.FindByUserAccount called %d times, expected 1", len(f.FindByUserAccountCalls))
	}
}

// FindByUserAccountCalledN returns true if FakeTransactionRepo.FindByUserAccount was called at least n times
func (f *FakeTransactionRepo) FindByUserAccountCalledN(n int) bool {
	return len(f.FindByUserAccountCalls) >= n
}

// AssertFindByUserAccountCalledN calls t.Error if FakeTransactionRepo.FindByUserAccount was called less than n times
func (f *FakeTransactionRepo) AssertFindByUserAccountCalledN(t TransactionRepoTestingT, n int) {
	t.Helper()
	if len(f.FindByUserAccountCalls) < n {
		t.Errorf("FakeTransactionRepo.FindByUserAccount called %d times, expected >= %d", len(f.FindByUserAccountCalls), n)
	}
}

// FindByUserAccountCalledWith returns true if FakeTransactionRepo.FindByUserAccount was called with the given values
func (f_sym50 *FakeTransactionRepo) FindByUserAccountCalledWith(userID int, accountID int) bool {
	for _, call_sym50 := range f_sym50.FindByUserAccountCalls {
		if reflect.DeepEqual(call_sym50.Parameters.UserID, userID) && reflect.DeepEqual(call_sym50.Parameters.AccountID, accountID) {
			return true
		}
	}

	return false
}

// AssertFindByUserAccountCalledWith calls t.Error if FakeTransactionRepo.FindByUserAccount was not called with the given values
func (f_sym51 *FakeTransactionRepo) AssertFindByUserAccountCalledWith(t TransactionRepoTestingT, userID int, accountID int) {
	t.Helper()
	var found_sym51 bool
	for _, call_sym51 := range f_sym51.FindByUserAccountCalls {
		if reflect.DeepEqual(call_sym51.Parameters.UserID, userID) && reflect.DeepEqual(call_sym51.Parameters.AccountID, accountID) {
			found_sym51 = true
			break
		}
	}

	if !found_sym51 {
		t.Error("FakeTransactionRepo.FindByUserAccount not called with expected parameters")
	}
}

// FindByUserAccountCalledOnceWith returns true if FakeTransactionRepo.FindByUserAccount was called exactly once with the given values
func (f_sym52 *FakeTransactionRepo) FindByUserAccountCalledOnceWith(userID int, accountID int) bool {
	var count_sym52 int
	for _, call_sym52 := range f_sym52.FindByUserAccountCalls {
		if reflect.DeepEqual(call_sym52.Parameters.UserID, userID) && reflect.DeepEqual(call_sym52.Parameters.AccountID, accountID) {
			count_sym52++
		}
	}

	return count_sym52 == 1
}

// AssertFindByUserAccountCalledOnceWith calls t.Error if FakeTransactionRepo.FindByUserAccount was not called exactly once with the given values
func (f_sym53 *FakeTransactionRepo) AssertFindByUserAccountCalledOnceWith(t TransactionRepoTestingT, userID int, accountID int) {
	t.Helper()
	var count_sym53 int
	for _, call_sym53 := range f_sym53.FindByUserAccountCalls {
		if reflect.DeepEqual(call_sym53.Parameters.UserID, userID) && reflect.DeepEqual(call_sym53.Parameters.AccountID, accountID) {
			count_sym53++
		}
	}

	if count_sym53 != 1 {
		t.Errorf("FakeTransactionRepo.FindByUserAccount called %d times with expected parameters, expected one", count_sym53)
	}
}

// FindByUserAccountResultsForCall returns the result values for the first call to FakeTransactionRepo.FindByUserAccount with the given values
func (f_sym54 *FakeTransactionRepo) FindByUserAccountResultsForCall(userID int, accountID int) (ident1 []model.Transaction, ident2 error, found_sym54 bool) {
	for _, call_sym54 := range f_sym54.FindByUserAccountCalls {
		if reflect.DeepEqual(call_sym54.Parameters.UserID, userID) && reflect.DeepEqual(call_sym54.Parameters.AccountID, accountID) {
			ident1 = call_sym54.Results.Ident1
			ident2 = call_sym54.Results.Ident2
			found_sym54 = true
			break
		}
	}

	return
}

func (f_sym55 *FakeTransactionRepo) Create(ident1 *model.Transaction) (ident2 error) {
	if f_sym55.CreateHook == nil {
		panic("TransactionRepo.Create() called but FakeTransactionRepo.CreateHook is nil")
	}

	invocation_sym55 := new(TransactionRepoCreateInvocation)
	f_sym55.CreateCalls = append(f_sym55.CreateCalls, invocation_sym55)

	invocation_sym55.Parameters.Ident1 = ident1

	ident2 = f_sym55.CreateHook(ident1)

	invocation_sym55.Results.Ident2 = ident2

	return
}

// SetCreateStub configures TransactionRepo.Create to always return the given values
func (f_sym56 *FakeTransactionRepo) SetCreateStub(ident2 error) {
	f_sym56.CreateHook = func(*model.Transaction) error {
		return ident2
	}
}

// SetCreateInvocation configures TransactionRepo.Create to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym57 *FakeTransactionRepo) SetCreateInvocation(calls_sym57 []*TransactionRepoCreateInvocation, fallback_sym57 func() error) {
	f_sym57.CreateHook = func(ident1 *model.Transaction) (ident2 error) {
		for _, call_sym57 := range calls_sym57 {
			if reflect.DeepEqual(call_sym57.Parameters.Ident1, ident1) {
				ident2 = call_sym57.Results.Ident2

				return
			}
		}

		return fallback_sym57()
	}
}

// CreateCalled returns true if FakeTransactionRepo.Create was called
func (f *FakeTransactionRepo) CreateCalled() bool {
	return len(f.CreateCalls) != 0
}

// AssertCreateCalled calls t.Error if FakeTransactionRepo.Create was not called
func (f *FakeTransactionRepo) AssertCreateCalled(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.CreateCalls) == 0 {
		t.Error("FakeTransactionRepo.Create not called, expected at least one")
	}
}

// CreateNotCalled returns true if FakeTransactionRepo.Create was not called
func (f *FakeTransactionRepo) CreateNotCalled() bool {
	return len(f.CreateCalls) == 0
}

// AssertCreateNotCalled calls t.Error if FakeTransactionRepo.Create was called
func (f *FakeTransactionRepo) AssertCreateNotCalled(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.CreateCalls) != 0 {
		t.Error("FakeTransactionRepo.Create called, expected none")
	}
}

// CreateCalledOnce returns true if FakeTransactionRepo.Create was called exactly once
func (f *FakeTransactionRepo) CreateCalledOnce() bool {
	return len(f.CreateCalls) == 1
}

// AssertCreateCalledOnce calls t.Error if FakeTransactionRepo.Create was not called exactly once
func (f *FakeTransactionRepo) AssertCreateCalledOnce(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.CreateCalls) != 1 {
		t.Errorf("FakeTransactionRepo.Create called %d times, expected 1", len(f.CreateCalls))
	}
}

// CreateCalledN returns true if FakeTransactionRepo.Create was called at least n times
func (f *FakeTransactionRepo) CreateCalledN(n int) bool {
	return len(f.CreateCalls) >= n
}

// AssertCreateCalledN calls t.Error if FakeTransactionRepo.Create was called less than n times
func (f *FakeTransactionRepo) AssertCreateCalledN(t TransactionRepoTestingT, n int) {
	t.Helper()
	if len(f.CreateCalls) < n {
		t.Errorf("FakeTransactionRepo.Create called %d times, expected >= %d", len(f.CreateCalls), n)
	}
}

// CreateCalledWith returns true if FakeTransactionRepo.Create was called with the given values
func (f_sym58 *FakeTransactionRepo) CreateCalledWith(ident1 *model.Transaction) bool {
	for _, call_sym58 := range f_sym58.CreateCalls {
		if reflect.DeepEqual(call_sym58.Parameters.Ident1, ident1) {
			return true
		}
	}

	return false
}

// AssertCreateCalledWith calls t.Error if FakeTransactionRepo.Create was not called with the given values
func (f_sym59 *FakeTransactionRepo) AssertCreateCalledWith(t TransactionRepoTestingT, ident1 *model.Transaction) {
	t.Helper()
	var found_sym59 bool
	for _, call_sym59 := range f_sym59.CreateCalls {
		if reflect.DeepEqual(call_sym59.Parameters.Ident1, ident1) {
			found_sym59 = true
			break
		}
	}

	if !found_sym59 {
		t.Error("FakeTransactionRepo.Create not called with expected parameters")
	}
}

// CreateCalledOnceWith returns true if FakeTransactionRepo.Create was called exactly once with the given values
func (f_sym60 *FakeTransactionRepo) CreateCalledOnceWith(ident1 *model.Transaction) bool {
	var count_sym60 int
	for _, call_sym60 := range f_sym60.CreateCalls {
		if reflect.DeepEqual(call_sym60.Parameters.Ident1, ident1) {
			count_sym60++
		}
	}

	return count_sym60 == 1
}

// AssertCreateCalledOnceWith calls t.Error if FakeTransactionRepo.Create was not called exactly once with the given values
func (f_sym61 *FakeTransactionRepo) AssertCreateCalledOnceWith(t TransactionRepoTestingT, ident1 *model.Transaction) {
	t.Helper()
	var count_sym61 int
	for _, call_sym61 := range f_sym61.CreateCalls {
		if reflect.DeepEqual(call_sym61.Parameters.Ident1, ident1) {
			count_sym61++
		}
	}

	if count_sym61 != 1 {
		t.Errorf("FakeTransactionRepo.Create called %d times with expected parameters, expected one", count_sym61)
	}
}

// CreateResultsForCall returns the result values for the first call to FakeTransactionRepo.Create with the given values
func (f_sym62 *FakeTransactionRepo) CreateResultsForCall(ident1 *model.Transaction) (ident2 error, found_sym62 bool) {
	for _, call_sym62 := range f_sym62.CreateCalls {
		if reflect.DeepEqual(call_sym62.Parameters.Ident1, ident1) {
			ident2 = call_sym62.Results.Ident2
			found_sym62 = true
			break
		}
	}

	return
}

func (f_sym63 *FakeTransactionRepo) Update(ident1 *model.Transaction) (ident2 error) {
	if f_sym63.UpdateHook == nil {
		panic("TransactionRepo.Update() called but FakeTransactionRepo.UpdateHook is nil")
	}

	invocation_sym63 := new(TransactionRepoUpdateInvocation)
	f_sym63.UpdateCalls = append(f_sym63.UpdateCalls, invocation_sym63)

	invocation_sym63.Parameters.Ident1 = ident1

	ident2 = f_sym63.UpdateHook(ident1)

	invocation_sym63.Results.Ident2 = ident2

	return
}

// SetUpdateStub configures TransactionRepo.Update to always return the given values
func (f_sym64 *FakeTransactionRepo) SetUpdateStub(ident2 error) {
	f_sym64.UpdateHook = func(*model.Transaction) error {
		return ident2
	}
}

// SetUpdateInvocation configures TransactionRepo.Update to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym65 *FakeTransactionRepo) SetUpdateInvocation(calls_sym65 []*TransactionRepoUpdateInvocation, fallback_sym65 func() error) {
	f_sym65.UpdateHook = func(ident1 *model.Transaction) (ident2 error) {
		for _, call_sym65 := range calls_sym65 {
			if reflect.DeepEqual(call_sym65.Parameters.Ident1, ident1) {
				ident2 = call_sym65.Results.Ident2

				return
			}
		}

		return fallback_sym65()
	}
}

// UpdateCalled returns true if FakeTransactionRepo.Update was called
func (f *FakeTransactionRepo) UpdateCalled() bool {
	return len(f.UpdateCalls) != 0
}

// AssertUpdateCalled calls t.Error if FakeTransactionRepo.Update was not called
func (f *FakeTransactionRepo) AssertUpdateCalled(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.UpdateCalls) == 0 {
		t.Error("FakeTransactionRepo.Update not called, expected at least one")
	}
}

// UpdateNotCalled returns true if FakeTransactionRepo.Update was not called
func (f *FakeTransactionRepo) UpdateNotCalled() bool {
	return len(f.UpdateCalls) == 0
}

// AssertUpdateNotCalled calls t.Error if FakeTransactionRepo.Update was called
func (f *FakeTransactionRepo) AssertUpdateNotCalled(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.UpdateCalls) != 0 {
		t.Error("FakeTransactionRepo.Update called, expected none")
	}
}

// UpdateCalledOnce returns true if FakeTransactionRepo.Update was called exactly once
func (f *FakeTransactionRepo) UpdateCalledOnce() bool {
	return len(f.UpdateCalls) == 1
}

// AssertUpdateCalledOnce calls t.Error if FakeTransactionRepo.Update was not called exactly once
func (f *FakeTransactionRepo) AssertUpdateCalledOnce(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.UpdateCalls) != 1 {
		t.Errorf("FakeTransactionRepo.Update called %d times, expected 1", len(f.UpdateCalls))
	}
}

// UpdateCalledN returns true if FakeTransactionRepo.Update was called at least n times
func (f *FakeTransactionRepo) UpdateCalledN(n int) bool {
	return len(f.UpdateCalls) >= n
}

// AssertUpdateCalledN calls t.Error if FakeTransactionRepo.Update was called less than n times
func (f *FakeTransactionRepo) AssertUpdateCalledN(t TransactionRepoTestingT, n int) {
	t.Helper()
	if len(f.UpdateCalls) < n {
		t.Errorf("FakeTransactionRepo.Update called %d times, expected >= %d", len(f.UpdateCalls), n)
	}
}

// UpdateCalledWith returns true if FakeTransactionRepo.Update was called with the given values
func (f_sym66 *FakeTransactionRepo) UpdateCalledWith(ident1 *model.Transaction) bool {
	for _, call_sym66 := range f_sym66.UpdateCalls {
		if reflect.DeepEqual(call_sym66.Parameters.Ident1, ident1) {
			return true
		}
	}

	return false
}

// AssertUpdateCalledWith calls t.Error if FakeTransactionRepo.Update was not called with the given values
func (f_sym67 *FakeTransactionRepo) AssertUpdateCalledWith(t TransactionRepoTestingT, ident1 *model.Transaction) {
	t.Helper()
	var found_sym67 bool
	for _, call_sym67 := range f_sym67.UpdateCalls {
		if reflect.DeepEqual(call_sym67.Parameters.Ident1, ident1) {
			found_sym67 = true
			break
		}
	}

	if !found_sym67 {
		t.Error("FakeTransactionRepo.Update not called with expected parameters")
	}
}

// UpdateCalledOnceWith returns true if FakeTransactionRepo.Update was called exactly once with the given values
func (f_sym68 *FakeTransactionRepo) UpdateCalledOnceWith(ident1 *model.Transaction) bool {
	var count_sym68 int
	for _, call_sym68 := range f_sym68.UpdateCalls {
		if reflect.DeepEqual(call_sym68.Parameters.Ident1, ident1) {
			count_sym68++
		}
	}

	return count_sym68 == 1
}

// AssertUpdateCalledOnceWith calls t.Error if FakeTransactionRepo.Update was not called exactly once with the given values
func (f_sym69 *FakeTransactionRepo) AssertUpdateCalledOnceWith(t TransactionRepoTestingT, ident1 *model.Transaction) {
	t.Helper()
	var count_sym69 int
	for _, call_sym69 := range f_sym69.UpdateCalls {
		if reflect.DeepEqual(call_sym69.Parameters.Ident1, ident1) {
			count_sym69++
		}
	}

	if count_sym69 != 1 {
		t.Errorf("FakeTransactionRepo.Update called %d times with expected parameters, expected one", count_sym69)
	}
}

// UpdateResultsForCall returns the result values for the first call to FakeTransactionRepo.Update with the given values
func (f_sym70 *FakeTransactionRepo) UpdateResultsForCall(ident1 *model.Transaction) (ident2 error, found_sym70 bool) {
	for _, call_sym70 := range f_sym70.UpdateCalls {
		if reflect.DeepEqual(call_sym70.Parameters.Ident1, ident1) {
			ident2 = call_sym70.Results.Ident2
			found_sym70 = true
			break
		}
	}

	return
}

func (f_sym71 *FakeTransactionRepo) Delete(userID int, tranID int) (ident1 error) {
	if f_sym71.DeleteHook == nil {
		panic("TransactionRepo.Delete() called but FakeTransactionRepo.DeleteHook is nil")
	}

	invocation_sym71 := new(TransactionRepoDeleteInvocation)
	f_sym71.DeleteCalls = append(f_sym71.DeleteCalls, invocation_sym71)

	invocation_sym71.Parameters.UserID = userID
	invocation_sym71.Parameters.TranID = tranID

	ident1 = f_sym71.DeleteHook(userID, tranID)

	invocation_sym71.Results.Ident1 = ident1

	return
}

// SetDeleteStub configures TransactionRepo.Delete to always return the given values
func (f_sym72 *FakeTransactionRepo) SetDeleteStub(ident1 error) {
	f_sym72.DeleteHook = func(int, int) error {
		return ident1
	}
}

// SetDeleteInvocation configures TransactionRepo.Delete to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym73 *FakeTransactionRepo) SetDeleteInvocation(calls_sym73 []*TransactionRepoDeleteInvocation, fallback_sym73 func() error) {
	f_sym73.DeleteHook = func(userID int, tranID int) (ident1 error) {
		for _, call_sym73 := range calls_sym73 {
			if reflect.DeepEqual(call_sym73.Parameters.UserID, userID) && reflect.DeepEqual(call_sym73.Parameters.TranID, tranID) {
				ident1 = call_sym73.Results.Ident1

				return
			}
		}

		return fallback_sym73()
	}
}

// DeleteCalled returns true if FakeTransactionRepo.Delete was called
func (f *FakeTransactionRepo) DeleteCalled() bool {
	return len(f.DeleteCalls) != 0
}

// AssertDeleteCalled calls t.Error if FakeTransactionRepo.Delete was not called
func (f *FakeTransactionRepo) AssertDeleteCalled(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.DeleteCalls) == 0 {
		t.Error("FakeTransactionRepo.Delete not called, expected at least one")
	}
}

// DeleteNotCalled returns true if FakeTransactionRepo.Delete was not called
func (f *FakeTransactionRepo) DeleteNotCalled() bool {
	return len(f.DeleteCalls) == 0
}

// AssertDeleteNotCalled calls t.Error if FakeTransactionRepo.Delete was called
func (f *FakeTransactionRepo) AssertDeleteNotCalled(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.DeleteCalls) != 0 {
		t.Error("FakeTransactionRepo.Delete called, expected none")
	}
}

// DeleteCalledOnce returns true if FakeTransactionRepo.Delete was called exactly once
func (f *FakeTransactionRepo) DeleteCalledOnce() bool {
	return len(f.DeleteCalls) == 1
}

// AssertDeleteCalledOnce calls t.Error if FakeTransactionRepo.Delete was not called exactly once
func (f *FakeTransactionRepo) AssertDeleteCalledOnce(t TransactionRepoTestingT) {
	t.Helper()
	if len(f.DeleteCalls) != 1 {
		t.Errorf("FakeTransactionRepo.Delete called %d times, expected 1", len(f.DeleteCalls))
	}
}

// DeleteCalledN returns true if FakeTransactionRepo.Delete was called at least n times
func (f *FakeTransactionRepo) DeleteCalledN(n int) bool {
	return len(f.DeleteCalls) >= n
}

// AssertDeleteCalledN calls t.Error if FakeTransactionRepo.Delete was called less than n times
func (f *FakeTransactionRepo) AssertDeleteCalledN(t TransactionRepoTestingT, n int) {
	t.Helper()
	if len(f.DeleteCalls) < n {
		t.Errorf("FakeTransactionRepo.Delete called %d times, expected >= %d", len(f.DeleteCalls), n)
	}
}

// DeleteCalledWith returns true if FakeTransactionRepo.Delete was called with the given values
func (f_sym74 *FakeTransactionRepo) DeleteCalledWith(userID int, tranID int) bool {
	for _, call_sym74 := range f_sym74.DeleteCalls {
		if reflect.DeepEqual(call_sym74.Parameters.UserID, userID) && reflect.DeepEqual(call_sym74.Parameters.TranID, tranID) {
			return true
		}
	}

	return false
}

// AssertDeleteCalledWith calls t.Error if FakeTransactionRepo.Delete was not called with the given values
func (f_sym75 *FakeTransactionRepo) AssertDeleteCalledWith(t TransactionRepoTestingT, userID int, tranID int) {
	t.Helper()
	var found_sym75 bool
	for _, call_sym75 := range f_sym75.DeleteCalls {
		if reflect.DeepEqual(call_sym75.Parameters.UserID, userID) && reflect.DeepEqual(call_sym75.Parameters.TranID, tranID) {
			found_sym75 = true
			break
		}
	}

	if !found_sym75 {
		t.Error("FakeTransactionRepo.Delete not called with expected parameters")
	}
}

// DeleteCalledOnceWith returns true if FakeTransactionRepo.Delete was called exactly once with the given values
func (f_sym76 *FakeTransactionRepo) DeleteCalledOnceWith(userID int, tranID int) bool {
	var count_sym76 int
	for _, call_sym76 := range f_sym76.DeleteCalls {
		if reflect.DeepEqual(call_sym76.Parameters.UserID, userID) && reflect.DeepEqual(call_sym76.Parameters.TranID, tranID) {
			count_sym76++
		}
	}

	return count_sym76 == 1
}

// AssertDeleteCalledOnceWith calls t.Error if FakeTransactionRepo.Delete was not called exactly once with the given values
func (f_sym77 *FakeTransactionRepo) AssertDeleteCalledOnceWith(t TransactionRepoTestingT, userID int, tranID int) {
	t.Helper()
	var count_sym77 int
	for _, call_sym77 := range f_sym77.DeleteCalls {
		if reflect.DeepEqual(call_sym77.Parameters.UserID, userID) && reflect.DeepEqual(call_sym77.Parameters.TranID, tranID) {
			count_sym77++
		}
	}

	if count_sym77 != 1 {
		t.Errorf("FakeTransactionRepo.Delete called %d times with expected parameters, expected one", count_sym77)
	}
}

// DeleteResultsForCall returns the result values for the first call to FakeTransactionRepo.Delete with the given values
func (f_sym78 *FakeTransactionRepo) DeleteResultsForCall(userID int, tranID int) (ident1 error, found_sym78 bool) {
	for _, call_sym78 := range f_sym78.DeleteCalls {
		if reflect.DeepEqual(call_sym78.Parameters.UserID, userID) && reflect.DeepEqual(call_sym78.Parameters.TranID, tranID) {
			ident1 = call_sym78.Results.Ident1
			found_sym78 = true
			break
		}
	}

	return
}
